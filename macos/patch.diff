diff --git a/src/client/client.cpp b/src/client/client.cpp
index d76f4010e..7506b0abe 100644
--- a/src/client/client.cpp
+++ b/src/client/client.cpp
@@ -202,8 +202,14 @@ void Client::loadMods()
 		}
 		paths["mods"] = path_user;
 
-		std::string settings_path = path_user + DIR_DELIM + "mods.conf";
-		modconf.addModsFromConfig(settings_path, paths);
+		std::string settings_path_user = path_user + DIR_DELIM + "mods.conf";
+		std::string settings_path_share = modsPath + DIR_DELIM + "mods.conf";
+
+		// Merge configs: share first (read-only), then user (overrides, writeback)
+		std::vector<std::pair<std::string, bool>> cfgs;
+		cfgs.emplace_back(settings_path_share, false);
+		cfgs.emplace_back(settings_path_user, true);
+		modconf.addModsFromConfigs(cfgs, paths);
 		modconf.checkConflictsAndDeps();
 	}
 
@@ -286,8 +292,13 @@ const std::string &Client::getBuiltinLuaPath()
 
 const std::string &Client::getClientModsLuaPath()
 {
-	static const std::string clientmods_dir = porting::path_share + DIR_DELIM + "clientmods";
-	return clientmods_dir;
+    static const std::string clientmods_dir = porting::path_share + DIR_DELIM + "clientmods";
+#if defined(__APPLE__)
+    // Ensure visibility regardless of log level
+    rawstream << "macOS: shared clientmods path (path_share/clientmods) = "
+              << clientmods_dir << std::endl;
+#endif
+    return clientmods_dir;
 }
 
 const std::vector<ModSpec>& Client::getMods() const
diff --git a/src/content/mod_configuration.cpp b/src/content/mod_configuration.cpp
index bcbdd89ea..848d10346 100644
--- a/src/content/mod_configuration.cpp
+++ b/src/content/mod_configuration.cpp
@@ -189,6 +189,96 @@ void ModConfiguration::addModsFromConfig(
 	}
 }
 
+void ModConfiguration::addModsFromConfigs(
+		const std::vector<std::pair<std::string, bool>> &settings_paths,
+		const std::unordered_map<std::string, std::string> &modPaths)
+{
+	// Merge load_mod_ entries from multiple configs.
+	// Later entries override earlier ones.
+	std::unordered_map<std::string, std::string> load_mod_names;
+	Settings conf_to_update; // user config to write back, if any
+	std::string conf_update_path;
+	bool have_conf_to_update = false;
+
+	for (const auto &sp : settings_paths) {
+		const std::string &path = sp.first;
+		Settings conf;
+		if (!path.empty())
+			conf.readConfigFile(path.c_str());
+		std::vector<std::string> names = conf.getNames();
+		for (const std::string &name : names) {
+			const auto &value = conf.get(name);
+			if (name.compare(0, 9, "load_mod_") == 0) {
+				std::string modname = name.substr(9);
+				if (value == "false" || value == "nil") {
+					// Explicitly disabled: remove from merged map
+					load_mod_names.erase(modname);
+				} else {
+					// Enabled or path-qualified: override
+					load_mod_names[modname] = value;
+				}
+			}
+		}
+		if (sp.second) {
+			conf_to_update = std::move(conf);
+			conf_update_path = path;
+			have_conf_to_update = true;
+		}
+	}
+
+	std::vector<ModSpec> addon_mods;
+	// Map of modname to alternative candidate paths (for error messages)
+	std::unordered_map<std::string, std::vector<std::string>> candidates;
+
+	for (const auto &modPath : modPaths) {
+		std::vector<ModSpec> addon_mods_in_path = flattenMods(getModsInPath(modPath.second, modPath.first));
+		for (const auto &mod : addon_mods_in_path) {
+			const auto &pair = load_mod_names.find(mod.name);
+			if (pair != load_mod_names.end()) {
+				if (is_yes(pair->second) || pair->second == mod.virtual_path) {
+					addon_mods.push_back(mod);
+				} else {
+					candidates[pair->first].emplace_back(mod.virtual_path);
+				}
+			} else if (have_conf_to_update) {
+				// Mirror behavior of single-config: remove stale entries in update target
+				conf_to_update.remove("load_mod_" + mod.name);
+			}
+		}
+	}
+
+	addMods(addon_mods);
+
+	// Remove loaded mods from `load_mod_names`
+	for (const ModSpec &mod : m_unsatisfied_mods)
+		load_mod_names.erase(mod.name);
+
+	// Complain about mods declared but not found
+	if (!load_mod_names.empty()) {
+		errorstream << "The following mods could not be found:";
+		for (const auto &pair : load_mod_names)
+			errorstream << " \"" << pair.first << "\"";
+		errorstream << std::endl;
+
+		for (const auto &pair : load_mod_names) {
+			const auto &candidate = candidates.find(pair.first);
+			if (candidate != candidates.end()) {
+				errorstream << "Unable to load " << pair.first << " as the specified path "
+							<< pair.second << " could not be found. "
+							<< "However, it is available in the following locations:"
+							<< std::endl;
+				for (const auto &path : candidate->second) {
+					errorstream << " - " << path << std::endl;
+				}
+			}
+		}
+	}
+
+	// Only write back the designated update config
+	if (have_conf_to_update && !conf_update_path.empty())
+		conf_to_update.updateConfigFile(conf_update_path.c_str());
+}
+
 void ModConfiguration::checkConflictsAndDeps()
 {
 	// report on name conflicts
diff --git a/src/content/mod_configuration.h b/src/content/mod_configuration.h
index 17436ef9a..e0857b25b 100644
--- a/src/content/mod_configuration.h
+++ b/src/content/mod_configuration.h
@@ -5,6 +5,7 @@
 #pragma once
 
 #include "mods.h"
+#include <utility>
 
 
 /**
@@ -66,6 +67,15 @@ class ModConfiguration
 	void addModsFromConfig(const std::string &settings_path,
 			const std::unordered_map<std::string, std::string> &modPaths);
 
+	/**
+	 * Adds mods specified by multiple config files, merging in order.
+	 * Later configs override earlier ones. Only the last config with
+	 * writeback=true will be updated on disk; others are read-only.
+	 * Each pair is (path_to_config, writeback).
+	 */
+	void addModsFromConfigs(const std::vector<std::pair<std::string, bool>> &settings_paths,
+			const std::unordered_map<std::string, std::string> &modPaths);
+
 	/**
 	 * Call this function once all mods have been added
 	 */
